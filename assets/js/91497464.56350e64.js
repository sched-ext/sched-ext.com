"use strict";(self.webpackChunksched_ext=self.webpackChunksched_ext||[]).push([[251],{3668:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scheds/rust/scx_bpfland/README","title":"scx_bpfland","description":"This is a single user-defined scheduler used within schedext, which is a Linux kernel feature which enables implementing kernel thread schedulers in BPF and dynamically loading them. Read more about schedext.","source":"@site/docs/scheds/rust/scx_bpfland/README.md","sourceDirName":"scheds/rust/scx_bpfland","slug":"/scheds/rust/scx_bpfland/","permalink":"/docs/scheds/rust/scx_bpfland/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/scheds/rust/scx_bpfland/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"RUST SCHEDULERS","permalink":"/docs/scheds/rust/"},"next":{"title":"scx_flash","permalink":"/docs/scheds/rust/scx_flash/"}}');var n=t(4848),r=t(8453);const a={},c="scx_bpfland",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Typical Use Case",id:"typical-use-case",level:2},{value:"Production Ready?",id:"production-ready",level:2}];function o(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"scx_bpfland",children:"scx_bpfland"})}),"\n",(0,n.jsxs)(s.p,{children:["This is a single user-defined scheduler used within ",(0,n.jsx)(s.a,{href:"https://github.com/sched-ext/scx/tree/main",children:"sched_ext"}),", which is a Linux kernel feature which enables implementing kernel thread schedulers in BPF and dynamically loading them. ",(0,n.jsx)(s.a,{href:"https://github.com/sched-ext/scx/tree/main",children:"Read more about sched_ext"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(s.p,{children:"scx_bpfland: a vruntime-based sched_ext scheduler that prioritizes interactive\nworkloads."}),"\n",(0,n.jsx)(s.p,{children:"This scheduler is derived from scx_rustland, but it is fully implemented in BPF.\nIt has a minimal user-space Rust part to process command line options, collect\nmetrics and log out scheduling statistics. The BPF part makes all the\nscheduling decisions."}),"\n",(0,n.jsx)(s.p,{children:"Tasks are categorized as either interactive or regular based on their average\nrate of voluntary context switches per second. Tasks that exceed a specific\nvoluntary context switch threshold are classified as interactive. Interactive\ntasks are prioritized in a higher-priority queue, while regular tasks are\nplaced in a lower-priority queue. Within each queue, tasks are sorted based on\ntheir weighted runtime: tasks that have higher weight (priority) or use the CPU\nfor less time (smaller runtime) are scheduled sooner, due to their a higher\nposition in the queue."}),"\n",(0,n.jsx)(s.p,{children:"Moreover, each task gets a time slice budget. When a task is dispatched, it\nreceives a time slice equivalent to the remaining unused portion of its\npreviously allocated time slice (with a minimum threshold applied). This gives\nlatency-sensitive workloads more chances to exceed their time slice when needed\nto perform short bursts of CPU activity without being interrupted (i.e.,\nreal-time audio encoding / decoding workloads)."}),"\n",(0,n.jsx)(s.h2,{id:"typical-use-case",children:"Typical Use Case"}),"\n",(0,n.jsx)(s.p,{children:"Interactive workloads, such as gaming, live streaming, multimedia, real-time\naudio encoding/decoding, especially when these workloads are running alongside\nCPU-intensive background tasks."}),"\n",(0,n.jsx)(s.p,{children:"In this scenario scx_bpfland ensures that interactive workloads maintain a high\nlevel of responsiveness."}),"\n",(0,n.jsx)(s.h2,{id:"production-ready",children:"Production Ready?"}),"\n",(0,n.jsx)(s.p,{children:"The scheduler is based on scx_rustland, implementing nearly the same scheduling\nalgorithm with minor changes and optimizations to be fully implemented in BPF."}),"\n",(0,n.jsx)(s.p,{children:"Given that the scx_rustland scheduling algorithm has been extensively tested,\nthis scheduler can be considered ready for production use."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>c});var i=t(6540);const n={},r=i.createContext(n);function a(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);