"use strict";(self.webpackChunksched_ext=self.webpackChunksched_ext||[]).push([[146],{2205:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"scheds/rust/scx_p2dq/README","title":"scx_p2dq","description":"Overview","source":"@site/docs/scheds/rust/scx_p2dq/README.md","sourceDirName":"scheds/rust/scx_p2dq","slug":"/scheds/rust/scx_p2dq/","permalink":"/docs/scheds/rust/scx_p2dq/","draft":false,"unlisted":false,"editUrl":"https://github.com/sched-ext/scx/blob/main/scheds/rust/scx_p2dq/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"scx_mitosis","permalink":"/docs/scheds/rust/scx_mitosis/"},"next":{"title":"scx_rlfifo","permalink":"/docs/scheds/rust/scx_rlfifo/"}}');var i=n(4848),a=n(8453);const r={},c="scx_p2dq",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Configuration",id:"configuration",level:3}];function l(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"scx_p2dq",children:"scx_p2dq"})}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(s.p,{children:"A simple pick 2 load balancing scheduler with (dumb) multi-layer queueing."}),"\n",(0,i.jsx)(s.p,{children:'The p2dq scheduler is a simple load balancing scheduler that uses a pick two\nalgorithm for load balancing. A fixed number of DSQs are created per LLC with\nincremental slice intervals. If a task is able to consume the majority of the\nassigned slice is it dispatched to a DSQ with a longer slice. Tasks that do not\nconsume more than half the slice are moved to shorter slice DSQs. The DSQs with\nthe shortest slice lengths are then determined to be "interactive". All DSQs on\nthe same LLC share the same vtime and there is special handling for\n(non)interactive tasks for load balancing purposes.'}),"\n",(0,i.jsx)(s.p,{children:"The scheduler handles all scheduling decisions in BPF and the userspace\ncomponent is only for metric reporting."}),"\n",(0,i.jsx)(s.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,i.jsx)(s.p,{children:"p2dq can perform well in a variety of workloads including interactive workloads\nsuch as gaming, batch processing and server applications. Tuning of of p2dq for\neach use case is required."}),"\n",(0,i.jsx)(s.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(s.p,{children:["The main idea behind p2dq is being able to classify which tasks are interactive\nand using a separate dispatch queue (DSQ) for them. Non interactive tasks\ncan have special properties such as being able to be load balanced across\nLLCs/NUMA nodes. The ",(0,i.jsx)(s.code,{children:"--autoslice"})," option will attempt to scale DSQ time slices\nbased on the ",(0,i.jsx)(s.code,{children:"--interactive-ratio"}),". DSQ time slices can also be set manually\nif the duration/distribution of tasks that are considered to be interactive is\nknown in advance. ",(0,i.jsx)(s.code,{children:"scxtop"})," can be used to get an understanding of time slice\nutilization so that DSQs can be properly configured. For desktop systems keeping\nthe interactive ratio small (ex: <5) and using a small number of queues (2) will\ngive a general performance with autoslice enabled."]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>c});var t=n(6540);const i={},a=t.createContext(i);function r(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);