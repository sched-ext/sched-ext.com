"use strict";(self.webpackChunksched_ext=self.webpackChunksched_ext||[]).push([[778],{6096:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>d,default:()=>l,frontMatter:()=>c,metadata:()=>n,toc:()=>i});const n=JSON.parse('{"id":"scheds/rust/scx_wd40/README","title":"scx_wd40","description":"An experimental fork of the scxrusty scheduler that uses BPF arenas to simplify scheduler development. Found in the main schedext repository. Read more about sched_ext.","source":"@site/docs/scheds/rust/scx_wd40/README.md","sourceDirName":"scheds/rust/scx_wd40","slug":"/scheds/rust/scx_wd40/","permalink":"/docs/scheds/rust/scx_wd40/","draft":false,"unlisted":false,"editUrl":"https://github.com/sched-ext/scx/blob/main/scheds/rust/scx_wd40/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"scx_tickless","permalink":"/docs/scheds/rust/scx_tickless/"}}');var r=t(4848),o=t(8453);const c={},d="scx_wd40",a={},i=[{value:"Overview",id:"overview",level:2},{value:"Goals",id:"goals",level:2},{value:"Production Ready?",id:"production-ready",level:2}];function h(e){const s={a:"a",h1:"h1",h2:"h2",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"scx_wd40",children:"scx_wd40"})}),"\n",(0,r.jsxs)(s.p,{children:["An experimental fork of the scx_rusty scheduler that uses BPF arenas to simplify scheduler development. Found in the main ",(0,r.jsx)(s.a,{href:"https://github.com/sched-ext/scx/tree/main",children:"sched_ext"})," repository. ",(0,r.jsx)(s.a,{href:"https://github.com/sched-ext/scx/tree/main",children:"Read more about sched_ext"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(s.p,{children:"A multi-domain, BPF / user space hybrid scheduler. The BPF portion of the\nscheduler does a simple round robin in each domain, and the user space portion\n(written in Rust) calculates the load factor of each domain, and informs BPF of\nhow tasks should be load balanced accordingly."}),"\n",(0,r.jsx)(s.h2,{id:"goals",children:"Goals"}),"\n",(0,r.jsx)(s.p,{children:"This scheduler ultimately aims to demonstrate how to build modular BPF schedulers\nto enable easy code reuse between scheduler codebases. The main way of achieving\nthis is through the use of BPF arenas that make it possible to directly share memory\nbetween the userspace and kernel scheduler components. This in turn lets us offload\nmost of the complexity of the scheduler to userspace. Userspace components can be\nmore easily combined, as opposed to scheduler BPF methods that are often mutually\nexclusive."}),"\n",(0,r.jsx)(s.h2,{id:"production-ready",children:"Production Ready?"}),"\n",(0,r.jsx)(s.p,{children:"No. This scheduler heavily uses BPF arenas and as such routinely requires a\nbleeding-edge kernel toolchain to even run and verify."})]})}function l(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>c,x:()=>d});var n=t(6540);const r={},o=n.createContext(r);function c(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);